function PlotSimSetup(roomsetup)
% PlotSimSetup(roomsetup.source,roomsetup.receiver,roomsetup.room)
%
% PlotSimSetup
% PlotSimSetup([],roomsetup.receiver)
% PlotSimSetup((roomsetup.source,roomsetup.receiver)
% PlotSimSetup(roomsetup.source,[],roomsetup.room)
% etc.
%
% Plot a 3d figure showing MCroomsetup.roomSim's configuration, i.e.:
% - the room dimensionensions
% - the source locations and orientations 
% - the receiver locations and orientations
%
% Omnidirectional roomsetup.source are figured by red spheres and omnidirectional 
% roomsetup.receiver are figured by blue spheres. Directional roomsetup.source/roomsetup.receiver
% are figured as red/blue spheres with an arrow showing their orientation.
%
% Inputs:
% - "roomsetup.source" is a source configuration structure, as generated by
%  MCroomsetup.roomSim's "AddSource" function.
% - "roomsetup.receiver" is a receiver configuration structure, as generated by
%  MCroomsetup.roomSim's "AddReceiver" function.
% - "roomsetup.room" is a room configuration structure, as generated by
%  MCroomsetup.roomSim's "Setuproomsetup.room" function.
%
% Copyright 2010, N. Epain, A. Wabnitz, CARLab & University of Sydney
% Last update: 09/08/2010




%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PROCESS INPUT VARIABLES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If an input is empty or doesn't exist then the default settings will be
% used
if isempty(roomsetup.source) || isempty(roomsetup.receiver) || isempty(roomsetup.room)
	error('please load params')
end

%%%%%%%%%%%%%%%%%%
% INITIALISATION %
%%%%%%%%%%%%%%%%%%

% Number of roomsetup.source and roomsetup.receiver
nmbSou = length(roomsetup.source) ;
nmbRec = length(roomsetup.receiver) ;

% Source and receiver locations
souLoc = zeros(nmbSou,3) ;
for I = 1 : nmbSou
    souLoc(I,:) = roomsetup.source(I).location ;
end
recLoc = zeros(nmbRec,3) ;isfield('roomsetup', 'source') 
for I = 1 : nmbRec
    recLoc(I,:) = roomsetup.receiver(I).location ;
end

% Test if a source or receiver is outside the room
souWalDst = repmat(roomsetup.room.dimension,nmbSou,1) - souLoc ;
recWalDst = repmat(roomsetup.room.dimension,nmbRec,1) - recLoc ;
if any(any([souLoc;recLoc;souWalDst;recWalDst]<0))
    error('roomsetup.source and roomsetup.receiver cannot be outside the room.') ;
end

% Calculate the distance between the roomsetup.receiver, between the roomsetup.source and
% between the roomsetup.receiver and roomsetup.source.
RecSouDst = sqrt( sum(( repmat(reshape(recLoc,nmbRec,1,3),1,nmbSou) ...
- repmat(permute(reshape(souLoc,nmbSou,1,3),[2 1 3]),nmbRec,1)).^2 ,3 ) ) ;
RecRecDst = sqrt( sum(( repmat(reshape(recLoc,nmbRec,1,3),1,nmbRec) ...
- repmat(permute(reshape(recLoc,nmbRec,1,3),[2 1 3]),nmbRec,1)).^2 ,3 ) ) ;
SouSouDst = sqrt( sum(( repmat(reshape(souLoc,nmbSou,1,3),1,nmbSou) ...
- repmat(permute(reshape(souLoc,nmbSou,1,3),[2 1 3]),nmbSou,1)).^2 ,3 ) ) ;

% Size of the source and receiver spheres
siz = roomsetup.room.dimension/10 ;
siz = min([siz,min(RecSouDst(RecSouDst>0))/2]) ;
siz = min([siz,min(RecRecDst(RecRecDst>0))/2]) ;
siz = min([siz,min(SouSouDst(SouSouDst>0))/2]) ;

% Sphere vertices
[xSph,ySph,zSph] = sphere ;
xSph = siz * xSph ;      
ySph = siz * ySph ;      
zSph = siz * zSph ;

% Search for source and/or roomsetup.receiver having the same location
SmeRec = RecRecDst==0 ;
SmeSou = SouSouDst==0 ;
RecCnt = zeros(nmbRec,1) ;
SouCnt = zeros(nmbSou,1) ;

% Initialise the figure
figure
set(gcf,'Color',[1 1 1])
hold on


%%%%%%%%%%%%%%%%%
% PLOT THE ROOM %
%%%%%%%%%%%%%%%%%

% roomsetup.room width
width = min(roomsetup.room.dimension(1:2)) ; 

% Regular mesh of points on the floor
stp = max(.25,(2^nextpow2(width/4))/4) ;
xFlr = (0:stp:roomsetup.room.dimension(1))' ;
yFlr = (0:stp:roomsetup.room.dimension(2))' ;
if roomsetup.room.dimension(1) > max(xFlr)
    xFlr = [ xFlr ; roomsetup.room.dimension(1) ] ;
end
if roomsetup.room.dimension(2) > max(yFlr)
    yFlr = [ yFlr ; roomsetup.room.dimension(2) ] ;
end

% Plot a checkered floor
for I = 1 : length(xFlr)-1
    for J = 1 : length(yFlr)-1
        % Color of the (I,J) tile
        col = [.7 .7 .7] + .1 * rem(I+J,2) ;
        % Create a patch corresponding to the (I,J) tile
        patch([xFlr(I) xFlr(I+1) xFlr(I+1) xFlr(I)], ...
              [yFlr(J) yFlr(J) yFlr(J+1) yFlr(J+1)], ...
              [0 0 0 0],'facecolor',col,'edgecolor','none') ;
    end
end
    


%%%%%%%%%%%%%%%%%%%%
% PLOT THE roomsetup.source %
%%%%%%%%%%%%%%%%%%%%

% Plot the roomsetup.source
for I = 1 : nmbSou
    
    % Ith source position
    pos = roomsetup.source(I).location ; 

    % Plot Ith source
    surf(pos(1)+xSph,pos(2)+ySph,pos(3)+zSph, ...
        'edgecolor','none','facecolor',[1 0 0]) ;
    
    % Plot Ith source orientation if directional
    if ~strcmp(roomsetup.source(I).description,'omnidirectional')
        orn = roomsetup.source(I).orientation * pi/180 ;
        [vec(1),vec(2),vec(3)] = sph2cart(orn(1),orn(2),3*siz) ;
        Arrow3d(pos,pos+vec,[1 0 0])
    end
    
    % Show the source index if more than one
    if nmbSou > 1
        nmbSmeSou = sum(SmeSou(:,I)) ;
        if nmbSmeSou > 1
            text(pos(1)+siz*cos(2*pi*SouCnt(I)/nmbSmeSou), ...
                 pos(2)+siz*sin(2*pi*SouCnt(I)/nmbSmeSou), ...
                 pos(3)+2*siz,num2str(I),'color',[1 0 0], ...
                 'HorizontalAlignment','center') ;
        else
             text(pos(1),pos(2),pos(3)+2*siz,num2str(I), ...
                 'color',[1 0 0],'HorizontalAlignment','center') ;           
        end
        SouCnt(SmeSou(:,I)) = SouCnt(SmeSou(:,I)) + 1 ;
    end

end


%%%%%%%%%%%%%%%%%%%%%%
% PLOT THE roomsetup.receiver %
%%%%%%%%%%%%%%%%%%%%%%

% Plot the roomsetup.source
for I = 1 : nmbRec
    
    % Ith receiver position
    pos = roomsetup.receiver(I).location ; 

    % Plot Ith receiver
    surf(pos(1)+xSph,pos(2)+ySph,pos(3)+zSph, ...
        'edgecolor','none','facecolor',[0 0 1]) ;
    
    % Plot Ith receiver orientation if directional
    if ~strcmp(roomsetup.receiver(I).description,'omnidirectional')
        orn = roomsetup.receiver(I).orientation * pi/180 ;
        [vec(1),vec(2),vec(3)] = sph2cart(orn(1),orn(2),3*siz) ;
        Arrow3d(pos,pos+vec,[0 0 1])
    end
    
    % Show the receiver index if more than one
    if nmbRec > 1
        nmbSmeRec = sum(SmeRec(I,:)) ;
        if nmbSmeRec > 1
            text(pos(1)+siz*cos(2*pi*RecCnt(I)/nmbSmeRec), ...
                 pos(2)+siz*sin(2*pi*RecCnt(I)/nmbSmeRec), ...
                 pos(3)+2*siz,num2str(I),'color',[0 0 1], ...
                 'HorizontalAlignment','center') ;
        else
            text(pos(1),pos(2),pos(3)+2*siz,num2str(I), ...
                'color',[0 0 1],'HorizontalAlignment','center') ;
        end
        RecCnt(SmeRec(I,:)) = RecCnt(SmeRec(I,:)) + 1 ;
    end

end


%%%%%%%%%%%% 
% AXES ETC %  
%%%%%%%%%%%% 

% Axes
axis equal
axis([0 roomsetup.room.dimension(1) 0 roomsetup.room.dimension(2) 0 roomsetup.room.dimension(3)])
axis vis3d
box on

% Perspective
camproj perspective
campos([-3 -9 12].*roomsetup.room.dimension)

% Lighting
light('Position',[0.5 0.5 0]+[0 0 1.5].*roomsetup.room.dimension,'Style','local')
lighting phong
material dull

% Axis labels
xlabel('x [m]')
ylabel('y [m]')
zlabel('z [m]')


end


%%%%%%%%%%%%%%%%
% SUB-ROUTINES %
%%%%%%%%%%%%%%%%

% Sub-routine: plot a 3d arrow
function Arrow3d(xyzStart,xyzEnd,col)

    % Corresponding vector
    vec = xyzEnd-xyzStart ;
    
    % Length of the arrow
    lng = norm(vec) ;
    
    % Arrow direction
    dir = vec/lng ;
    [azm,elv] = cart2sph(dir(1),dir(2),dir(3))  ;
    
    % A set of angles around the circle
    ang = linspace(0,360,18)' * pi/180 ;
    
    % Radius of the base of the arrow
    rad = lng / 20 ;
    
    % Plot the base of the arrow
    bas = rad * [zeros(length(ang),1) cos(ang) sin(ang)] ;
    bas = bas * YaxisRotMatrix(elv)' * ZaxisRotMatrix(azm)' ;
    bas = repmat(xyzStart,length(ang),1) + bas ; 
    patch(bas(:,1),bas(:,2),bas(:,3),ones(size(bas(:,1))), ...
        'edgecol','none','facecol',col) ;

    % Plot the shaft of the arrow
    shf = bas + repmat(.72*vec,length(ang),1) ;
    for I = 1 : length(ang)-1
        patch([bas(I,1);shf(I,1);shf(I+1,1);bas(I+1,1)], ...
              [bas(I,2);shf(I,2);shf(I+1,2);bas(I+1,2)], ...
              [bas(I,3);shf(I,3);shf(I+1,3);bas(I+1,3)], ...
              ones(4,1), ...
              'edgecol','none','facecol',col) ;
    end
    
    % Plot the base of the head
    bas = 4*rad*[zeros(length(ang),1) cos(ang) sin(ang)] ;
    bas = bas * YaxisRotMatrix(elv)' * ZaxisRotMatrix(azm)' ;
    bas = bas + repmat(xyzStart,length(ang),1) ...
        + .7*repmat(vec,length(ang),1) ;
    patch(bas(:,1),bas(:,2),bas(:,3),ones(size(bas(:,1))), ...
        'edgecol','none','facecol',col) ;

   % Plot the head
   hea = xyzEnd ;
   for I = 1 : length(ang)-1
       patch([bas(I,1);hea(1);bas(I+1,1)], ...
             [bas(I,2);hea(2);bas(I+1,2)], ...
             [bas(I,3);hea(3);bas(I+1,3)], ...
             ones(3,1), ...
             'edgecol','none','facecol',col) ;
   end
    
end

% Sub-routine: z-axis rotation matrix
function RotMat = ZaxisRotMatrix(ang) 
    RotMat = [ cos(ang) -sin(ang) 0 ; ...
               sin(ang)  cos(ang) 0 ; ...
                      0         0 1 ] ;
end

% Sub-routine: y-axis rotation matrix
function RotMat = YaxisRotMatrix(ang)
    RotMat = [ cos(ang) 0 sin(ang) ; ...
                      0 1        0 ; ...
              -sin(ang) 0 cos(ang) ] ;
end